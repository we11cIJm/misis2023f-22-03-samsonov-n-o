*Группа*: БПМ-22-3
*Студент*: Самсонов Николай Олегович
*Преподаватель*: Полевой Дмитрий Валерьевич

***Вопрос по выбору: “Структуры данных, lock-free”.
Введение:***

Lock-free – это методология обеспечения безопасности работы с данными в многозадачных приложениях без использования традиционных мьютексов и блокировок. Разделяемый объект называется lock-free объектом (неблокируемым объектом), если он гарантирует, что хотя бы один поток закончит выполнение операции над объектом за конечное число шагов вне зависимости от результата работы других потоков.

Обычно, структура данных называется lock-free, если одномоментно некоторые потоки будут выполнять операции над этим объектом, и другие потоки смогут выполнять операции чтения и записи без блокировки ресурса (объекта).

Проектирование обобщенных алгоритмов без блокировок является сложной задачей, поэтому вместо этого лучше разрабатывать структуры данных без блокировок. Например, такие как: buffer, list, stack, queue, map, deque. Но не стоит разрабатывать некоторые lock-free структуры данных по ряду причин:
1. дерево и граф: слишком сложны в реализации, так как имеют сложную логику и зависимости
2. динамический массив и хеш-таблицы: изменяющийся размер очень сильно усложняет задачу, так как изменение размера может потребовать атомарных операций над указателями и данными.
3. Структуры данных с взаимозависимыми операциями: Если операции в структуре данных тесно взаимосвязаны и требуют сериализации, введение lock-free механизмов может привести к сложным (или нерешаемым) проблемам согласованности.

Также методология lock-free скрывает за собой большое количество проблем, которые могут приводить к непредсказуемому поведению программы. Например:

- **ABA-проблема**: Если поток прочитал значение, а затем оно было изменено другим потоком и вернулось к оригинальному значению (ABA), то эта проблема может привести к неверному восприятию состояния данных.
- **Вероятность застопорившихся (live-lock) или взаимоблокирующих (deadlock) состояний**: В условиях высокой конкуренции за ресурсы, может возникнуть ситуация, когда потоки блокируют друг друга, ожидая выполнения определенных условий.
- **Неопределенные порядки выполнения**: Lock-free структуры данных не гарантируют определенного порядка выполнения операций между потоками, что может сделать сложным предсказание результатов.
- **Сложность отладки**: В случае проблем с параллелизмом и конкуренцией, отладка программы может стать гораздо сложнее из-за непредсказуемого порядка выполнения потоков.


Пример проблемы при разработке lock-free структуры данных:
```c++
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int*> sharedPointer(nullptr);

void writerThread() {
    for (int i = 0; i < 1000; ++i) {
        int* newValue = new int(i);
        int* oldValue = sharedPointer.exchange(newValue);
        delete oldValue; // Потенциальная утечка памяти
        // Допустим, здесь может быть прерывание потока
    }
}

void readerThread() {
    for (int i = 0; i < 1000; ++i) {
        int* valuePtr = sharedPointer.load();
        if (valuePtr != nullptr && *valuePtr % 2 == 0) {
            std::cout << "Even value: " << *valuePtr << std::endl;
        }
    }
}

int main() {
    std::thread writer(writerThread);
    std::thread reader(readerThread);
    
    writer.join();
    reader.join();
}
```


В данном примере есть проблема ABA: если поток reader прерван после того, как указатель sharedPointer был обновлен, но до того, как был выполнен delete oldValue в потоке writer, поток reader может разыменовать нулевой указатель, что может привести к непредсказуемому поведению или аварийному завершению программы.

Большинство многопоточных программ можно проверить на наличие различных стандартных ошибок, таких как: datarace, deadlock, livelock, race condition и др. Для того, чтобы обнаруживать ошибки на этапе компиляции можно пользоваться утилитой ThreadSanitizer. Для того, чтобы трассировать системные вызовы в runtime, можно воспользоваться утилитой strace, которая выведет последовательный список информации о каждом потоке и его вызовах. 
